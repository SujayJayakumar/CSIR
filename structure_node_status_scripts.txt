ðŸ”§ CSV Version: record_node_status_csv.py
 
import csv
import datetime
import paramiko
 
NODES_FILE = "nodes.txt"
CSV_FILE = "node_status_log.csv"
SSH_HOST = "your_user@your_host"  # <-- fill in
SSH_COMMAND = "pbsnodes -l"
 
 
def get_all_nodes():
    with open(NODES_FILE, "r") as f:
        return [line.strip() for line in f if line.strip()]
 
 
def run_remote_command():
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    host, user = SSH_HOST.split("@")
    client.connect(hostname=host, username=user)  # Add key_filename if needed
    stdin, stdout, stderr = client.exec_command(SSH_COMMAND)
    output = stdout.read().decode()
    client.close()
    return output
 
 
def parse_output(output):
    status_map = {}
    for line in output.strip().splitlines():
        if not line:
            continue
        parts = line.split()
        node_id = parts[0]
        status = " ".join(parts[1:])
        status_map[node_id] = {
            "is_down": "down" in status.lower(),
            "is_offline": "offline" in status.lower(),
        }
    return status_map
 
 
def write_to_csv(all_nodes, status_map):
    timestamp = datetime.datetime.now().replace(microsecond=0)
    with open(CSV_FILE, "a", newline="") as csvfile:
        writer = csv.writer(csvfile)
        for node in all_nodes:
            is_offline = status_map.get(node, {}).get("is_offline", False)
            is_down = status_map.get(node, {}).get("is_down", False)
            is_online = not is_offline and not is_down
            writer.writerow([node, timestamp, is_online, is_offline, is_down])
 
 
def main():
    all_nodes = get_all_nodes()
    output = run_remote_command()
    status_map = parse_output(output)
    write_to_csv(all_nodes, status_map)
 
 
if __name__ == "__main__":
    main()







#ðŸ§© DB Version: record_node_status_db.py
 
 
import psycopg2
import datetime
import paramiko
 
NODES_FILE = "nodes.txt"
SSH_HOST = "your_user@your_host"  # <-- fill in
SSH_COMMAND = "pbsnodes -l"
 
DB_CONFIG = {
    "dbname": "your_db",
    "user": "your_user",
    "password": "your_pass",
    "host": "your_host",
    "port": "5432"
}
 
 
def get_all_nodes():
    with open(NODES_FILE, "r") as f:
        return [line.strip() for line in f if line.strip()]
 
 
def run_remote_command():
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    host, user = SSH_HOST.split("@")
    client.connect(hostname=host, username=user)  # Add key_filename if needed
    stdin, stdout, stderr = client.exec_command(SSH_COMMAND)
    output = stdout.read().decode()
    client.close()
    return output
 
 
def parse_output(output):
    status_map = {}
    for line in output.strip().splitlines():
        if not line:
            continue
        parts = line.split()
        node_id = parts[0]
        status = " ".join(parts[1:])
        status_map[node_id] = {
            "is_down": "down" in status.lower(),
            "is_offline": "offline" in status.lower(),
        }
    return status_map
 
 
def insert_into_db(all_nodes, status_map):
    timestamp = datetime.datetime.now().replace(microsecond=0)
    conn = psycopg2.connect(**DB_CONFIG)
    cur = conn.cursor()
    for node in all_nodes:
        is_offline = status_map.get(node, {}).get("is_offline", False)
        is_down = status_map.get(node, {}).get("is_down", False)
        is_online = not is_offline and not is_down
 
        cur.execute("""
            INSERT INTO node_status (node_id, timestamp, is_online, is_offline, is_down)
            VALUES (%s, %s, %s, %s, %s)
            ON CONFLICT (node_id, timestamp) DO NOTHING;
        """, (node, timestamp, is_online, is_offline, is_down))
    conn.commit()
    cur.close()
    conn.close()
 
 
def main():
    all_nodes = get_all_nodes()
    output = run_remote_command()
    status_map = parse_output(output)
    insert_into_db(all_nodes, status_map)
 
 
if __name__ == "__main__":
    main()
